#!/bin/sh
# Copyright (c) 2012 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Prepares image resources into output folder.

# Composition settings
BACKGROUND_COLOR=white

# The only file that uses different scaling parameter.
BACKGROUND_IMAGE=Background_white.png

# Output file name.
BMPBLK_OUTPUT="bmpblock.bin"

die() {
  echo "ERROR: $*" >&2
  exit 1
}

convert_to_bmp3() {
  local input="$1"
  local folder="$2"
  local param="$3"
  local output="$(basename "$input")"

  # Always output as .bmp
  output="${output%.*}.bmp"
  mkdir -p "$folder"

  # When input has Alpha channel, we need to fill the background properly
  # otherwise ImageMagick will fill it with black.  The operation (-flatten) is
  # so slow so we only want to do that if the input source really has
  # transparency.
  if [ "$#" -gt 3 ]; then
    flatten="$4"
  else
    # Auto-detect
    if [ "$(identify -format "%A" "$input")" = "True" ]; then
      flatten="-background $BACKGROUND_COLOR -flatten"
    else
      flatten=""
    fi
  fi

  echo "$input -> $folder/$output $flatten"
  convert "$input" $flatten \
    -compress none -alpha off -colors 256 \
    $param "BMP3:$folder/$output"

  # ImageMagic quantization may choose arbitrary color depth, even if we assign
  # -depth or -colors; so a single-color background may become 1 bit per pixel
  # after convertion. To workaround that, we use Python Image Library which
  # always generates 8bpp BMP file.
  # TODO(hungte) Find a better way to decide if PIL is required. Unfortunately,
  # ImageMagic identify "%z" is not always what we're looking for...
  local fn="$folder/$output"
  local param="'P', dither=None, palette=Image.ADAPTIVE"
  python -c "import Image; Image.open('$fn').convert($param).save('$fn')"
}

main() {
  local profile="$1"
  local output="out_$1"
  local scale_param="" background_scale_param="" replace_files=""
  local base locale X

  # TODO(hungte) Derive and calculate profile params automatically.

  # Currently we use image resources originally designed for 1366x768, and
  # re-scale to different aspects on demand.
  case "$profile" in
    std )
      # Standard: profile with all default values.
      true
      ;;

    # Native profiles

    n1366 )
      # "Native 1366x768" resolution.
      background_scale_param="-scale 1366x768!"
      ;;

    n1366usb )
      # Similar to n1366, and can only boot recovery by USB.
      background_scale_param="-scale 1366x768!"
      replace_files="insert=insert_usb BadSD=dummy RemoveDevices=RemoveUSB"
      ;;

    n1366usb2 )
      # Similar to n1366, and can only boot recovery by SD card or USB2.
      background_scale_param="-scale 1366x768!"
      replace_files="insert=insert_sd_usb2"
      ;;

    # Stretched profiles

    s800 )
      # "Streched 800x600". Designed for x86 UEFI BIOS (and coreboot), which
      # always puts display into VESA 800x600 16-bit mode (0x0114), and is
      # stretched to fill the entire screen.
      scale_param="-scale 59%x78%"
      background_scale_param="-scale 800x600!"
      ;;

    s1024 )
      # Similar to s800, using VESA graphics mode 1024x768 (0x0117).
      scale_param="-scale 75%x100%"
      background_scale_param="-scale 1024x768!"
      ;;

    s1024usb )
      # Similar to s1024, and can only boot recovery by USB2. (No card reader,
      # not not able to recover from card reader.)
      scale_param="-scale 75%x100%"
      background_scale_param="-scale 1024x768!"
      replace_files="insert=insert_usb BadSD=dummy RemoveDevices=RemoveUSB"
      ;;

    s1024usb2 )
      # Similar to s1024, and can only boot recovery by SD card or USB2.
      scale_param="-scale 75%x100%"
      background_scale_param="-scale 1024x768!"
      replace_files="insert=insert_sd_usb2"
      ;;

    s1280a8x5 )
      # Similar to s1024, using VESA graphics mode 1280x1024 (0x011A), and
      # adjusted for aspect ratio 8x5 panels.
      background_scale_param="-scale 1280x1024!"
      scale_param="-scale 94%x119%"  # 119% = 133% * (1.6 / 1.78)
      ;;

    s1280x850a8x5 )
      # Similar to s1280a8x5, using graphics mode 1280x850.
      background_scale_param="-scale 1280x850!"
      scale_param="-scale 94%x99%" # 99% = 110% * (1.6 / 1.78)
      ;;

    * )
      die "Sorry, unknown profile $profile."
  esac

  # Prepare output folder
  rm -rf "$output"
  mkdir -p "$output"

  # Prepare images in current folder
  # TODO(hungte) Deprecate arrow*.bmp by markup &#x25c0; and &#x25b6;, and
  # Url.bmp by <span foreground="blue">http://</span>.
  for X in *.png assets/*.png; do
    if [ "$X" = "$BACKGROUND_IMAGE" ]; then
      convert_to_bmp3 "$X" "$output" "$background_scale_param"
    else
      convert_to_bmp3 "$X" "$output" "$scale_param"
    fi
  done

  # Prepares strings and localized images. All these images were rendered by
  # pango-view and should not have transparency, so we specify flatten="" to
  # speed up.
  echo "Preparing common strings..."
  base="../strings"
  for X in $base/*.png; do
    convert_to_bmp3 "$X" "$output" "$scale_param" ""
  done

  echo "Preparing localized messages... $LOCALES"
  base="../strings/localized_text"
  if [ -z "$LOCALES" ]; then
    # Collect all locales
    for X in $(cd $base; ls); do
      if [ -d "$base/$X" ]; then
        LOCALES="${LOCALES}${X} "
      fi
    done
    echo "Found locales: $LOCALES"
  fi
  for locale in $LOCALES; do
    # Prepare all locales.
    for X in $base/$locale/*.png; do
      convert_to_bmp3 "$X" "$output/locale/$locale" "$scale_param" ""
    done
  done

  if [ -n "$replace_files" ]; then
    echo "Replacing files..."
    echo "$replace_files" | tr ' ' '\n' | while read X; do
      local Xdest="${X%%=*}" Xsrc="${X##*=}" Xfile=""
      echo " $Xsrc => $Xdest"
      for Xfile in $(find "$output" -name "$Xsrc.bmp"); do
        echo "  * $Xfile"
        mv "$Xfile" "$(dirname "$Xfile")/$Xdest.bmp"
      done
    done
  fi

  echo "Preparing fonts..."
  base="../strings/font"
  for X in $base/*.png; do
    convert_to_bmp3 "$X" "$output/font" "$scale_param" ""
  done
  bmpblk_font --outfile "$output/hwid_fonts.bin" "$output"/font/*.bmp

  # Create YAML file.
  (cd "$output" && ../make_default_yaml $LOCALES)

  # Compile bitmap block file.
  (cd "$output" && bmpblk_utility -c DEFAULT.yaml $BMPBLK_OUTPUT)
  ls -l "$output/$BMPBLK_OUTPUT"
}

set -e
main "$@"

